#include <Serial.h>
#include <Timer.h>
#include "BlinkToRadio.h"

module BlinkToRadioC {
   uses interface Boot;
   uses interface Leds;
   uses interface Timer<TMilli> as Timer0; 
   

   uses interface AMPacket;
   uses interface Packet  as RadioPacket;
   uses interface AMSend as AMRadioSend;
   uses interface Receive as RadioReceive;
   uses interface SplitControl as AMRadioControl;
   
   
   uses interface SplitControl as AMSerialControl;
   uses interface Receive as AMSerialReceive;
   uses interface AMSend  as AMSerialSend;
   uses interface Packet  as SerialPacket;
   uses interface SendBytePacket;
 
 
    interface AMSend as UartSend[am_id_t id];
    interface Receive as UartReceive[am_id_t id];
    interface Packet as UartPacket;
    interface AMPacket as UartAMPacket;
    
    interface AMSend as RadioSend[am_id_t id];
    interface Receive as RadioReceive[am_id_t id];
    interface Packet as RadioPacket;
    interface AMPacket as RadioAMPacket;
 
 
}

implementation {
   uint16_t   counter = 0;
   bool  busy = FALSE;
   bool  sbusy = FALSE;
   message_t   pkt;
   message_t   serialpkt;
   

   event  void Boot.booted()
      {
       call AMSerialControl.start();
       }
  


   event  void AMRadioControl.startDone(error_t err) {
       if (err == SUCCESS)  {
       // Timer should not start before Radio is initialized and ready
       call Timer0.startPeriodic(TIMER_PERIOD_MILLI);
       }
       else {
             call AMRadioControl.start();
            }
    }


    event  void AMRadioControl.stopDone(error_t err) {
	   call AMRadioControl.start();
    }

   event  void AMSerialControl.startDone(error_t err) {
       if (err == SUCCESS)  {
             call AMRadioControl.start();   // Start the Radio control after serial control is completed
											//
       }
       else {
             call AMSerialControl.start();
            }
    }


 event void AMSerialControl.stopDone(error_t err) {
    call AMSerialControl.start();
  }
 

event void Timer0.fired()
       {
       counter++;
//       call Leds.set(counter);
       if (!busy)  
          {
          BlinkToRadioMsg* btrpkt = (BlinkToRadioMsg*) (call RadioPacket.getPayload(&pkt, NULL));
          btrpkt->nodeid = TOS_NODE_ID;
          btrpkt->counter = counter;
          if (call AMRadioSend.send(AM_BROADCAST_ADDR, &pkt, sizeof(BlinkToRadioMsg)) == SUCCESS) {
              busy = TRUE;
             }
       }
 
   }


event void AMRadioSend.sendDone(message_t* msg, error_t error) {
 // if(&pkt == msg)  {
                    busy = FALSE;
//                   }
}



  event void AMSerialSend.sendDone(message_t* bufPtr, error_t error) {
  
  sbusy = FALSE;
  }
  
  event message_t* AMSerialReceive.receive(message_t* msg, void* payload, uint8_t len) {


  }


 event message_t* RadioReceive.receive(message_t* msg, void* payload, uint8_t len) {
 if (len == sizeof(BlinkToRadioMsg)) {
     message_t  *myret = msg;			//Save a pointer to the message 
     BlinkToRadioMsg* btrmsg =(BlinkToRadioMsg*) payload;
     //call Leds.set(btrmsg->counter);
   
     if (!sbusy)  
          {
          BlinkToRadioMsg* btrpkt = (BlinkToRadioMsg*) (call SerialPacket.getPayload(&serialpkt, NULL));
          btrpkt->nodeid = 0xEEEE;
          btrpkt->counter = btrmsg->counter;
          btrpkt->messagecount = counter;
          btrpkt->thatfield = 3;
          btrpkt->sourceaddress = call AMPacket.source(msg);
          
          call AMPacket.setDestination(&serialpkt,0xCCCC);
          call AMPacket.setSource(&serialpkt,0xBB);
          call AMPacket.setType(&serialpkt,0xCC);

          
          call SendBytePacket.startSend(0x41); 
          call SendBytePacket.startSend(0x41); 
          call SendBytePacket.startSend(0x41); 
          
          
          //if (call AMSerialSend.send(AM_BROADCAST_ADDR, &serialpkt, sizeof(BlinkToRadioMsg)) == SUCCESS) {
          //if (call AMSerialSend.send(AM_BROADCAST_ADDR, &myret, len) == SUCCESS) {
          
          
          call Leds.set(btrmsg->counter);
          sbusy = TRUE;
          }
       }


}
return msg;
}


}


